# -*- coding: utf-8 -*-
"""Minimask Creation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KDt7eJZTDaJoXgz7_jPe21VDpI6T8_jB
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

!pip install numpy --upgrade
!pip install mahotas
!pip install torch torchvision
!pip install -U git+https://github.com/luca-medeiros/lang-segment-anything.git


from lang_sam import LangSAM
import warnings
import numpy as np
import matplotlib.pyplot as plt
import requests
from PIL import Image
from io import BytesIO
import mahotas as mh

import numpy as np
import cv2
from PIL import Image
import matplotlib.pyplot as plt
import warnings


import cv2
import numpy as np


def calculate_granularity(mask):
    # Count the number of white and black pixels
    num_white_pixels = np.sum(mask == 1)
    num_black_pixels = np.sum(mask == 0)

    # Determine the majority color
    if num_white_pixels > num_black_pixels:  # Majority is white
        # Count black pixels surrounded by white pixels
        surrounded_black_pixels = 0

        # Iterate over each black pixel
        for i in range(1, mask.shape[0] - 1):
            for j in range(1, mask.shape[1] - 1):
                if mask[i, j] == 0:  # Check if the pixel is black
                    # Check if the pixel is surrounded by white pixels
                    if (mask[i-1, j] == 1 and mask[i+1, j] == 1 and
                        mask[i, j-1] == 1 and mask[i, j+1] == 1):
                        surrounded_black_pixels += 1

        # Calculate the ratio of surrounded black pixels to total black pixels
        if num_black_pixels == 0:
            return 0  # Handle the case where there are no black pixels
        else:
            ratio = surrounded_black_pixels / num_black_pixels
            return ratio
    else:  # Majority is black
        # Count white pixels surrounded by black pixels
        surrounded_white_pixels = 0

        # Iterate over each white pixel
        for i in range(1, mask.shape[0] - 1):
            for j in range(1, mask.shape[1] - 1):
                if mask[i, j] == 1:  # Check if the pixel is white
                    # Check if the pixel is surrounded by black pixels
                    if (mask[i-1, j] == 0 and mask[i+1, j] == 0 and
                        mask[i, j-1] == 0 and mask[i, j+1] == 0):
                        surrounded_white_pixels += 1

        # Calculate the ratio of surrounded white pixels to total white pixels
        if num_white_pixels == 0:
            return 0  # Handle the case where there are no white pixels
        else:
            ratio = surrounded_white_pixels / num_white_pixels
            return ratio

def find_most_granular_mask(masks):
    granularities = [calculate_granularity(mask) for mask in masks]

    # Find the index of the mask with the lowest ratio
    most_granular_index = np.argmin(granularities)

    return most_granular_index

def process_image(input_image_path, output_image_path):
    def find_masks(image, text_prompt, box_threshold, text_threshold):
        # Suppress warning messages
        warnings.filterwarnings("ignore")
        try:
            model = LangSAM()
            masks, _, _, _ = model.predict(image, text_prompt, box_threshold=box_threshold, text_threshold=text_threshold)

            if len(masks) == 0:
                print()
            else:
                # Convert masks to numpy arrays
                masks_np = [mask.squeeze().cpu().numpy() for mask in masks]
                return masks_np

        except (requests.exceptions.RequestException, IOError) as e:
            print()



    def combine_masks(masks):
        combined_mask = np.zeros_like(masks[0], dtype=np.uint8)

        for mask in masks:
            combined_mask = np.logical_or(combined_mask, mask)

        return combined_mask.astype(np.uint8) * 255


    # Load image
    image_pil = Image.open(input_image_path).convert("RGB")

    # Find masks for vegetation
    vegetation_masks = find_masks(image_pil, "vegetation", box_threshold=0.3, text_threshold=0.3)
    if vegetation_masks:

        # Combine vegetation masks
        combined_vegetation_mask = combine_masks(vegetation_masks)

        image_og = np.array(image_pil)
        image = combined_vegetation_mask.copy()
        image2 = combined_vegetation_mask.copy()



    # Now find masks for road or pathway using the updated image
    road_masks = find_masks(image_pil, "road or pathway", box_threshold=0.17, text_threshold=0.17)
    if road_masks:
        most_granular_index = find_most_granular_mask(road_masks)

        print (most_granular_index)

        num_white_pixels = np.sum(road_masks[most_granular_index] == 1)
        num_black_pixels = np.sum(road_masks[most_granular_index] == 0)
        print (num_white_pixels,num_black_pixels)

        image_shape = road_masks[most_granular_index].shape
        image_height = image_shape[0]
        image_width = image_shape[1]

        print("Image height:", image_height)
        print("Image width:", image_width)


        if num_white_pixels > num_black_pixels:  # Majority is white
          if num_black_pixels<203357:
            image[road_masks[most_granular_index] == 0] = 255



        else:
          if num_white_pixels<203357:
            image[road_masks[most_granular_index] == 1] = 255



        num_black_pixels = count_black_pixels(image)
        if num_black_pixels<0.7*(360000):
          cv2.imwrite(output_image_path, image)  # Convert BGR to RGB before saving
        else:
          cv2.imwrite(output_image_path, image2)  # Convert BGR to RGB before saving



    else:
        print()


def count_black_pixels(image):
    # Check if the image is already grayscale or binary
    if len(image.shape) == 2:
        # No need to convert, as it's already grayscale or binary
        return cv2.countNonZero(image)

    # Convert the image to grayscale
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Threshold the grayscale image to get binary image (black and white)
    _, binary_image = cv2.threshold(gray_image, 1, 255, cv2.THRESH_BINARY)

    # Count black pixels
    num_black_pixels = cv2.countNonZero(binary_image)

    return num_black_pixels

import os

def main(input_dir, output_dir):
    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # List all files in the input directory
    files = os.listdir(input_dir)
    num=0
    for file in files:
        # Check if the file is an image and contains the word "slum" in its filename
        if (file.endswith('.jpg') or file.endswith('.jpeg') or file.endswith('.png')) and 'slum' in file:

            input_image_path = os.path.join(input_dir, file)
            output_image_path = os.path.join(output_dir, file)
            output_image_path = output_image_path.replace("slum",'minimask')
            print (output_image_path)

            # Process the image
            process_image(input_image_path, output_image_path)
            print (input_image_path)


            og_image_pil = Image.open(input_image_path).convert("RGB")
            og_image = np.array(og_image_pil)
            cv2.imwrite(input_image_path2, og_image)
            print (input_image_path2)


            input_image_path = input_image_path.replace('slum','mask')
            og_image_pil = Image.open(input_image_path).convert("RGB")
            og_image = np.array(og_image_pil)
            cv2.imwrite(input_image_path, og_image)
            print (input_image_path)


            num+=1
            print (num)



if __name__ == "__main__":
    # Mount Google Drive
    from google.colab import drive
    drive.mount('/content/drive')

    input_dir = '/content/drive/My Drive/SlumWMasks-V2-Train'  # Update with the path to your input directory in Google Drive
    output_dir = '/content/drive/My Drive/presegment_karachi_2'  # Update with the path to your output directory in Google Drive

    main(input_dir, output_dir)